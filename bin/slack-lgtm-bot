#!/usr/bin/env node

const co      = require('co')
const thenify = require('thenify')
const log     = require('fancy-log')

const RtmClient = require('@slack/client').RtmClient
const WebClient = require('@slack/client').WebClient
const LgtmIn    = require('../lib/lgtm_in')

const token      = process.env.SLACK_API_TOKEN
const lgtmInUrls = []
const botUser    = {
  username: process.env.SLACK_USERNAME || 'LGTM',
  icon_url: process.env.SLACK_ICON_URL || '',
}

if (!token) {
  log.error('`SLACK_API_TOKEN` not found')
  process.exit(1)
}

if (process.env.LGTM_IN_URL) {
  lgtmInUrls.push(process.env.LGTM_IN_URL)
}

if (process.env.LGTM_IN_URLS) {
  const urls = process.env.LGTM_IN_URLS.split(',')
  for (let url of urls) {
    if (url) {
      lgtmInUrls.push(url)
    }
  }
}

if (lgtmInUrls.length === 0) {
  lgtmInUrls.push('http://lgtm.in/g')
}

const startedAt = (new Date()).getTime()
const lgtmIn    = new LgtmIn(lgtmInUrls)
const rtm       = new RtmClient(token, { autoReconnect: true, logLevel: 'error' })
const web       = new WebClient(token)

log('Listening ...')
rtm.start()

rtm.on('authenticated', message => co(function* () {
  log('Connected')

  try {
    const teamInfo = yield thenify(web.team.info.bind(web.team))()
    delete teamInfo['team']['icon']
    log('Team:', JSON.stringify(teamInfo))
  } catch (e) {
    log.error(e)
  }
}))

rtm.on('message', message => co(function* () {
  try {
    const channel = message.channel
    const ts      = parseFloat(message.ts) * 1000
    const pattern = /^LGTM$/i

    if (startedAt < ts && pattern.test(message.text)) {
      log('Recevied:', JSON.stringify(message))

      const imageUrl = yield lgtmIn.next()
      yield (web.chat.postMessage.bind(web.chat))(channel, imageUrl, botUser)

      log('Posted:', imageUrl)
    }
  } catch (e) {
    log.error(e)
  }
}))


// vim: se et ts=2 sw=2 sts=0 ft=javascript :
